<snippet>
  <content><![CDATA[
/**
 * @brief Sliding Window Median (SWM)
 *
 * Maintains a dynamic multiset supporting:
 *   - add(x)
 *   - remove(x)
 *   - lower_median()              -> exact median for odd size
 *   - interpolated_median()       -> average of two middles for even size
 *   - sum_absolute_deviation()     -> sum(|x - median|) in current window
 *
 * Invariants:
 *   - `left`  contains the smaller half
 *   - `right` contains the larger half
 *   - |left| == |right|  OR  |left| == |right| + 1
 *   - median = last element in `left`
 *
 * Complexity:
 *   add/remove: O(log n)
 *   query median: O(1)
 */

template<class T>
struct SlidingWindowMedian {

    /** Insert element x. */
    void add(T x) {
        if (left.empty() || x <= *left.rbegin()) {
            left.insert(x);
            left_sum += x;
        } else {
            right.insert(x);
            right_sum += x;
        }
        total_size++;
        rebalance();
    }

    /** Remove existing element x. */
    void remove(T x) {
        assert(total_size > 0);

        auto it = left.find(x);
        if (it != left.end()) {
            left.erase(it);
            left_sum -= x;
        } else {
            it = right.find(x);
            if (it == right.end()) {
                assert(false && "Attempted to remove element not present in SWM");
            }
            right.erase(it);
            right_sum -= x;
        }

        total_size--;
        rebalance();
    }

    /** Lower median = middle element (for odd), left middle (for even). */
    T lower_median() const {
        assert(!left.empty());
        return *left.rbegin();
    }

    /**
     * @return Median as double:
     *   odd size → exact median
     *   even size → average of two middles
     */
    auto interpolated_median() const
        -> decltype((1.0 * T() + T()) / 2.0)
    {
        if (total_size & 1) {
            return lower_median();
        }
        assert(!right.empty());
        return (1.0 * (*left.rbegin()) + (*right.begin())) / 2.0;
    }

    /** Sum of absolute deviations from the lower median */
    long long sum_absolute_deviation() const {
        assert(!left.empty());
        long long med = lower_median();
        long long left_contrib  = (long long)left.size() * med - left_sum;
        long long right_contrib = right_sum - (long long)right.size() * med;
        return left_contrib + right_contrib;
    }

private:
    multiset<T> left;   ///< behaves like max-heap (largest at end)
    multiset<T> right;  ///< behaves like min-heap (smallest at begin)

    size_t total_size = 0;
    long long left_sum = 0, right_sum = 0;

    /** Restore size invariants between left and right. */
    void rebalance() {
        // Case 1: Move small element from right → left
        while (left.size() < right.size()) {
            auto it = right.begin();
            T val = *it;
            right.erase(it);
            right_sum -= val;
            left.insert(val);
            left_sum += val;
        }
        // Case 2: Move large element from left → right
        while (left.size() > right.size() + 1) {
            auto it = prev(left.end());
            T val = *it;
            left.erase(it);
            left_sum -= val;
            right.insert(val);
            right_sum += val;
        }
    }
};

template<class T>
using SWM = SlidingWindowMedian<T>;

]]></content>
  <tabTrigger>snpSlidingWindowMedian</tabTrigger>
  <description>Sliding window median</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <!-- <scope >source.python</scope > -->
</snippet>