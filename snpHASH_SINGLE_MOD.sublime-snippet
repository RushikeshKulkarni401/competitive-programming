<snippet>
  <content><![CDATA[
#include <sys/time.h>    
typedef uint64_t ull;
static int C; // initialized below

// single Mod hash component
template<int M>
struct A {
    int x; A() : x(0) {}
    A(int x) : x(x) {}
    A operator+(A o){int y = x+o.x; return{y - (y>=M)*M};}
    A operator-(A o){int y = x-o.x; return{y + (y< 0)*M};}
    A operator*(A o) { return {(int)(1LL*x*o.x % M)}; }
    explicit operator ull() { return x; }
    bool operator==(A o) const { return (ull)*this == (ull)o; }
    bool operator<(A o) const { return (ull)*this < (ull)o; }
};
typedef A<${0:1000000009}> H;

ll getH1(H cur_h) { return cur_h.x; }  // returns 1st hash
ll equals(H h1, H h2) { return getH1(h1) == getH1(h2); }

// Overload the << operator to print the two hash components of H
std::ostream& operator<<(std::ostream& os, const H& h) {
    os << "{" << getH1(h) << "}"; // Printing the first and second hashes
    return os;
}

vector<H> c_pwr;
H P(int x) {
    while(sz(c_pwr) < x + 1){
        c_pwr.push_back(c_pwr.back() * C);
    };
    return c_pwr[x];
}

template <class T> 
struct HashInterval {
    vector<H> ha;
    HashInterval(T& str) : ha(sz(str)+1) {
        for (ll i = 0; i < sz(str); i++)
            ha[i+1] = ha[i] * C + str[i];
    }
    H hashInterval(int a, int b) { // hash [a, b)
        return ha[b] - ha[a] * P(b - a);
    }
};

// returns hashes of all substrings of length = `length`
template <class T>
vector<H> getHashes(T& str, int length) {
    if (sz(str) < length) return {};
    H h = 0;
    for (ll i = 0; i < length; i++)
        h = h * C + str[i];
    vector<H> ret = {h};
    for (ll i = length; i < sz(str); i++) {
        ret.push_back(h = h * C + str[i] - P(length) * str[i-length]);
    }
    return ret;
}

template<class T> H hashString(T& s){H h{}; for(char c:s) h=h*C+c;return h;}

void setup_hash() {
    timeval tp;
    gettimeofday(&tp, 0);
    C = (int)tp.tv_usec;
    c_pwr.resize(1, 1);
}

/*
    ### Paste in main ###
    // usually this gives wrong answer due to high collision rate
    // use this hash with length wise buckets
    // maybe some map<size,set<hash>>? or vector<set<hash>> v(length)?
    setup_hash();
*/
]]></content>
  <tabTrigger>snpHASH_SINGLE_MOD</tabTrigger>
  <description>Single-Mod Hash</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <!-- <scope >source.python</scope > -->
</snippet>