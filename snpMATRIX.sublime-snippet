<snippet>
  <content><![CDATA[
/*
FOUND A RARE ITEM !! if you are needing to use this implies you're doing good !!, 

quick recap - 
Here, if you want to calculate [dp1,dp2....dpn] values after 'K' identical transitions where each dp value has identical type of contribution to other dp values in all transitions, you will multiply this 1*n matrix(m0) with Kth power of transition matrix(mx). where transition matrix is a n*n matrix which has multiplication coefficients of each dpx value for each other dpx values. 
If some dpx has no effect on dpy, then multiplication coefficient is 0. It is easy to store m0 (initial state matrix) as 1*n matrix. In transition matrix(n*n),  

first column will be the coefficient factors A,B,C if dp0=A*dp0+B*dp1+C*dp2, 

2nd col is D,E,F if 
dp1=D*dp0+E*dp1+F*dp2

3rd col is G,H,I if 
dp2=G*dp0+H*dp1+I*dp2

Matrix-Init (m0) (1*n)       = [dp0   dp1     dp2]
                                x
Matrix-transition (mx) (n*n) = [A    D   G] 
                               [B    E   H]
                               [C    F   I]

Answer(1*n) = m0 * (mx ^ k)
Be sure while implementing matrix multiplication, i,j,k (order is-i,j,k) loop variables are different than floyd warshall (which has order-k,i,j)
*/    
template <class T>
struct Matrix {
    Matrix(size_t siz) : Matrix(siz, siz) {}
    Matrix(size_t rows, size_t cols) : ROWS(rows), COLS(cols) {
        mat.resize(ROWS, std::vector<T>(COLS, 0));
    }
    Matrix(const vector<vector<T>>& v) {
        ROWS = v.size(), COLS = v[0].size();
        mat = v;
    }
    // Identity matrix constructor
    static Matrix identity(int n) {
        Matrix id(n, n);
        for (int i = 0; i < n; ++i) {
            id[i][i] = 1;
        }
        return id;
    }
    
    // Overload the multiplication operator
    Matrix operator*(const Matrix& other) const {
        if (COLS != other.ROWS) {
            throw std::invalid_argument("Incompatible matrix dimensions for multiplication.");
        }

        Matrix result(ROWS, other.COLS);
        for (size_t i = 0; i < ROWS; ++i) {
            for (size_t j = 0; j < other.COLS; ++j) {
                for (size_t k = 0; k < COLS; ++k) {
                    result[i][j] += mat[i][k] * other[k][j];
                }
            }
        }
        return result;
    }
  
    // Overload the exponentiation operator - only works for square matrices
    // precedence ( * >> ^ )  
    Matrix operator^(long long exponent) const {
        if (ROWS != COLS) {
            throw std::invalid_argument("Exponentiation only supports square matrices.");
        }

        Matrix result = Matrix::identity(ROWS);
        Matrix base = *this;
        while (exponent > 0) {
            if (exponent & 1) {
                result = result * base;
            }
            base = base * base;
            exponent >>= 1;
        }

        return result;
    }
    
    // Overload the [] operator
    std::vector<T>& operator[](int index) {
        return mat[index];
    }
    const std::vector<T>& operator[](int index) const {
        return mat[index];
    }
    
    friend std::ostream& operator<<(std::ostream& os, const Matrix& m) {
        os << m.mat;
        return os;
    }
    
private:
    vector<vector<T>> mat;
    size_t ROWS, COLS;
};
]]></content>
  <tabTrigger>snpMATRIX</tabTrigger>
  <description>Matrix Multiplication</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <!-- <scope >source.python</scope > -->
</snippet>