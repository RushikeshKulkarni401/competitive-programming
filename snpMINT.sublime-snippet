<snippet>
  <content><![CDATA[
// -MODULAR-
template<int P>
struct Modular {
    Modular() : x{} {}
    Modular(long long x) : x{norm(x % P)} {}
    
    int norm(int x) { if (x < 0) { x += P;} if (x >= P) { x -= P;} return x; }
    int operator()() const { return x; }
    Modular inv() const { assert(x != 0); return pwr(*this, P - 2); }
    explicit operator long long () { return x; }  //** Warning : Explicit **
    
    // unary
    Modular operator - () const { return Modular(-x); }
    Modular operator ++ ()  { x = norm(++x); return *this; }
    Modular operator -- () { x = norm(--x); return *this; }
    Modular operator ++ (int) { Modular result = *this; ++*this; return result; }
    Modular operator -- (int) { Modular result = *this; --*this; return result; }
    Modular &operator*=(const Modular &rhs) { x = 1LL * x * rhs() % P; return *this; }
    Modular &operator+=(const Modular &rhs) { x = norm(x + rhs()); return *this;}
    Modular &operator-=(const Modular &rhs) { x = norm(x - rhs()); return *this; }  
    Modular &operator/=(const Modular &rhs) { return *this *= rhs.inv(); }
 
    // equality
    friend bool operator == (const Modular &lhs, const Modular &rhs) { return lhs() == rhs(); }
    friend bool operator <  (const Modular &lhs, const Modular &rhs) { return lhs() < rhs(); }
    friend bool operator >  (const Modular &lhs, const Modular &rhs) { return lhs() > rhs(); }
    friend bool operator >= (const Modular &lhs, const Modular &rhs) { return lhs() >= rhs(); }
    friend bool operator <= (const Modular &lhs, const Modular &rhs) { return lhs() <= rhs(); }
 
    // binary
    friend Modular operator*(const Modular &lhs, const Modular &rhs) { return Modular(lhs) *= rhs; }
    friend Modular operator+(const Modular &lhs, const Modular &rhs) { return Modular(lhs) += rhs; }
    friend Modular operator-(const Modular &lhs, const Modular &rhs) { return Modular(lhs) -= rhs; }
    friend Modular operator/(const Modular &lhs, const Modular &rhs) { return Modular(lhs) /= rhs; }
    
    // stream
    friend std::istream &operator>>(std::istream &is, Modular &a) { long long v; is >> v; a = Modular(v); return is; }
    friend std::ostream &operator<<(std::ostream &os, const Modular &a) { return os << a(); }
 
private:
    int x;
};
 
const int M = ${0:1000000007}; 
using mint = Modular<M>;

mint pwr(mint a, ll b) { mint res = 1; while (b>0) { if (b&1) res *= a; a *= a; b >>= 1; } return res; } 
 
/*vector<mint> fact(1, 1);
vector<mint> inv_fact(1, 1);

mint F(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n];
}

mint I(int n) {
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return inv_fact[n];
}

mint C(int n, int k) {
    if (k < 0 || k > n) {
        return 0;
    }
    while ((int) fact.size() < n + 1) {
        fact.push_back(fact.back() * (int) fact.size());
        inv_fact.push_back(1 / fact.back());
    }
    return fact[n] * inv_fact[k] * inv_fact[n - k];
}*/
]]></content>
  <tabTrigger>snpMINT</tabTrigger>
  <description>MODULAR</description>
  <!-- Optional: Set a scope to limit where the snippet will trigger -->
  <!-- <scope >source.python</scope > -->
</snippet>