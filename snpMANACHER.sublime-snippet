<snippet>
	<content><![CDATA[
struct Manacher {
    Manacher(const string& s_) : s(s_), n(s_.size()), p(build(s)), 
                                 start_at(n, 0), end_at(n, 0) {
        populate_bounds();
    }

    // length of longest palindromic substring (start index + len)
    pair<int,int> longest_palindromic_substring() {
        int mx = 0, idx = 0;
        for (int i = 0; i < (int)p.size(); i++) {
            if (mx < p[i] - 1)
                mx = p[i] - 1, idx = (i >> 1) - (p[i] - 2) / 2;
        }
        return {idx, mx};
    }

    // check if s[l...r-1] is palindrome
    bool is_pal(int l, int r) {
        int len = r-- - l;
        l <<= 1, r <<= 1;
        return p[(l + r) >> 1] - 1 >= len;
    }

    int lps_start(int i) const {
        return (i >= 0 && i < n) ? start_at[i] : 0;
    }

    int lps_end(int i) const {
        return (i >= 0 && i < n) ? end_at[i] : 0;
    }

private:
    int n;
    string s;
    vector<int> p;
    vector<int> start_at, end_at;

    // Boundary handling
    void populate_bounds() {
        for (int i = 0; i < (int)p.size(); i++) {
            int len = p[i] - 1;
            int idx = (i >> 1) - (p[i] - 2) / 2;
            if (idx >= 0 && idx < n)
                start_at[idx] = max(start_at[idx], len);
            int end_idx = idx + len - 1;
            if (end_idx >= 0 && end_idx < n)
                end_at[end_idx] = max(end_at[end_idx], len);
        }
        for (int i = 1; i < n; i++)
            start_at[i] = max(start_at[i], start_at[i - 1] - 2);
        for (int i = n - 2; i >= 0; i--)
            end_at[i] = max(end_at[i], end_at[i + 1] - 2);
    }

    // Core palindrome logic
    vector<int> build(const string& s) {
        int m = 2 * s.size() + 1;
        vector<int> p(m);
        int l = 0, r = -1;
        for (int i = 0; i < m; i++) {
            int k = (i > r) ? 1 : min(p[l + r - i], r - i + 1);
            while (i - k >= 0 && i + k < m) {
                char a = (i - k) % 2 ? s[(i - k) / 2] : '#';
                char b = (i + k) % 2 ? s[(i + k) / 2] : '#';
                if (a != b) break;
                ++k;
            }
            p[i] = k;
            if (i + k - 1 > r) l = i - k + 1, r = i + k - 1;
        }
        return vector<int>(p.begin() + 1, p.end() - 1);
    }
};
]]></content>
	<!-- Optional: Set a tabTrigger to define how to trigger the snippet -->
	<tabTrigger>snpMANACHER</tabTrigger>
	<!-- Optional: Set a scope to limit where the snippet will trigger -->
	<!-- <scope>source.python</scope> -->
</snippet>
